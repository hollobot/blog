# 动态规划

动态规划（dynamic programming）是一个重要的算法范式，它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率。



## 一、记忆化搜索

#### 1. 题目背景：

[`leetCode`](https://leetcode.cn/problems/unique-paths?envType=study-plan-v2&envId=top-100-liked)：一个机器人从 `m x n` 网格的左上角 (1,1) 走到右下角 (m,n)，每次只能向下或向右走，求有多少条不同的路径。

![image-20260214151244020](./assets/image-20260214151244020.png)

#### 2. 算法拆解

##### （1）基础思路：深度优先搜索（DFS）

- **递归逻辑**：机器人在位置 `(m1, n1)` 时，只有两种选择：向下走 `(m1+1, n1)` 或向右走 `(m1, n1+1)`。

- 终止条件：

  - 若走出网格（`m1>m` 或 `n1>n`），路径无效，返回 0；
  - 若到达终点 `(m,n)`，找到一条有效路径，返回 1。

  

- **核心公式**：`当前位置路径数 = 向下走的路径数 + 向右走的路径数`。

##### （2）优化：记忆化搜索（Memoization）

单纯的 DFS 会存在大量**重复计算**（比如不同路径会走到同一个位置 `(m1, n1)`，重复递归计算该位置的路径数），因此代码中加入了 `memor` 数组：

- `memor[m1][n1]` 存储位置 `(m1, n1)` 到终点的路径数；
- 每次递归前先检查 `memor[m1][n1]`，若不为 0（已计算过），直接返回缓存值，避免重复递归；
- 计算完当前位置的路径数后，存入 `memor` 数组，供后续复用。

#### 3. 代码实现

```java
class Solution {
    public int uniquePaths(int m, int n) {
        // 初始化记忆化数组，大小 (m+1)x(n+1)（因为坐标从1开始）
        int[][] memor = new int[m+1][n+1];
        // 从起点(1,1)开始递归
        return dfs(m, n, 1, 1, memor);
    }

    public int dfs(int m, int n, int m1, int n1, int[][] memor) {
        // 终止条件1：走出网格，路径无效
        if (m1 > m || n1 > n) {
            return 0;
        }

        // 终止条件2：到达终点，找到1条有效路径
        if (m1 == m && n1 == n) {
            return 1;
        }

        // 记忆化核心：如果当前位置已计算过，直接返回缓存值
        if (memor[m1][n1] != 0) {
            return memor[m1][n1];
        }

        // 递归计算向下走的路径数
        int f1 = dfs(m, n, m1 + 1, n1, memor);
        // 递归计算向右走的路径数
        int f2 = dfs(m, n, m1, n1 + 1, memor);
        // 缓存当前位置的路径数（向下+向右）
        memor[m1][n1] = f1 + f2;
        // 返回当前位置的总路径数
        return f1 + f2;
    }
}
```



## 例题

### [1. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring)

#### **题目介绍**：

- 给你一个字符串 `s`，找到 `s` 中最长的 回文 子串。

#### **示例** ：

```
示例 1：
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。

示例 2：
输入：s = "cbbd"
输出："bb"
```

#### 算法实现

**方法一：中心扩展法(推荐)**

这是最直观且效率较高的方法,时间复杂度 O(n²),空间复杂度 O(1)。

```java
public class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 1) {
            return "";
        }
        
        int start = 0;
        int end = 0;
        
        for (int i = 0; i < s.length(); i++) {
            // 以单个字符为中心扩展(处理奇数长度回文)
            int len1 = expandAroundCenter(s, i, i);
            // 以两个字符之间为中心扩展(处理偶数长度回文)
            int len2 = expandAroundCenter(s, i, i + 1);
            
            int len = Math.max(len1, len2);
            
            // 更新最长回文子串的起始和结束位置
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        
        return s.substring(start, end + 1);
    }
    
    // 从中心向两边扩展,返回回文长度
    private int expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        // 返回回文长度
        return right - left - 1;
    }
}
```



### [2. 编辑距离](https://leetcode.cn/problems/edit-distance)

#### **题目介绍**：

- 给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。

- 你可以对一个单词进行如下三种操作：

  - 插入一个字符

  - 删除一个字符

  - 替换一个字符

#### **示例** ：

```
示例 1：
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')

示例 2：
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

#### 代码实现

**方法一：记忆化搜索**

题目的三种操作可以抽线为以下操作

- dfs(n - 1, m) = 删除一个元素
- dfs(n, m - 1) = 添加一个元素
- dfs(n - 1, m - 1) = 修改一个元素

```java
class Solution {
    private char[] w1, w2;
    private int[][] memo;

    public int minDistance(String word1, String word2) {
        w1 = word1.toCharArray();
        w2 = word2.toCharArray();
        int n = w1.length;
        int m = w2.length;
        memo = new int[n][m];
        for (int[] row : memo) {
            Arrays.fill(row, -1);
        }
        return dfs(n - 1, m - 1);
    }

    public int dfs(int n, int m) {

        if (m < 0) {
            return n + 1;
        }

        if (n < 0) {
            return m + 1;
        }

        if (memo[n][m] != -1) {
            return memo[n][m];
        }

        if (w1[n] == w2[m]) {
            // 这里相当符合条件，不需要调整。
            return memo[n][m] = dfs(n - 1, m - 1);
        }

        // 关键！！！
        // dfs(n - 1, m) = 删除一个元素
        // dfs(n, m - 1) = 添加一个元素
        // dfs(n - 1, m - 1) = 修改一个元素
        return memo[n][m] = Math.min(Math.min(dfs(n - 1, m), dfs(n, m - 1)), dfs(n - 1, m - 1)) + 1;
    }
}
```

