# 动态规划

动态规划（dynamic programming）是一个重要的算法范式，它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率。



## 一、记忆化搜索

#### 1. 题目背景：

[`leetCode`](https://leetcode.cn/problems/unique-paths?envType=study-plan-v2&envId=top-100-liked)：一个机器人从 `m x n` 网格的左上角 (1,1) 走到右下角 (m,n)，每次只能向下或向右走，求有多少条不同的路径。

![image-20260214151244020](./assets/image-20260214151244020.png)

#### 2. 算法拆解

##### （1）基础思路：深度优先搜索（DFS）

- **递归逻辑**：机器人在位置 `(m1, n1)` 时，只有两种选择：向下走 `(m1+1, n1)` 或向右走 `(m1, n1+1)`。

- 终止条件：

  - 若走出网格（`m1>m` 或 `n1>n`），路径无效，返回 0；
  - 若到达终点 `(m,n)`，找到一条有效路径，返回 1。

  

- **核心公式**：`当前位置路径数 = 向下走的路径数 + 向右走的路径数`。

##### （2）优化：记忆化搜索（Memoization）

单纯的 DFS 会存在大量**重复计算**（比如不同路径会走到同一个位置 `(m1, n1)`，重复递归计算该位置的路径数），因此代码中加入了 `memor` 数组：

- `memor[m1][n1]` 存储位置 `(m1, n1)` 到终点的路径数；
- 每次递归前先检查 `memor[m1][n1]`，若不为 0（已计算过），直接返回缓存值，避免重复递归；
- 计算完当前位置的路径数后，存入 `memor` 数组，供后续复用。

#### 3. 代码实现

```java
class Solution {
    public int uniquePaths(int m, int n) {
        // 初始化记忆化数组，大小 (m+1)x(n+1)（因为坐标从1开始）
        int[][] memor = new int[m+1][n+1];
        // 从起点(1,1)开始递归
        return dfs(m, n, 1, 1, memor);
    }

    public int dfs(int m, int n, int m1, int n1, int[][] memor) {
        // 终止条件1：走出网格，路径无效
        if (m1 > m || n1 > n) {
            return 0;
        }

        // 终止条件2：到达终点，找到1条有效路径
        if (m1 == m && n1 == n) {
            return 1;
        }

        // 记忆化核心：如果当前位置已计算过，直接返回缓存值
        if (memor[m1][n1] != 0) {
            return memor[m1][n1];
        }

        // 递归计算向下走的路径数
        int f1 = dfs(m, n, m1 + 1, n1, memor);
        // 递归计算向右走的路径数
        int f2 = dfs(m, n, m1, n1 + 1, memor);
        // 缓存当前位置的路径数（向下+向右）
        memor[m1][n1] = f1 + f2;
        // 返回当前位置的总路径数
        return f1 + f2;
    }
}
```

​	
