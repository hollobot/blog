# 策略模式

策略模式作为一种软件设计模式，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。
策略模式，定义了一组算法（业务规则），封装了每个算法，这族的算法可互换代替（interchangeable）。



### **策略模式特点**

**核心关注点**

- **关注行为执行**：解决"如何做事情"的问题
- **算法选择**：在多种算法中动态选择一种

**主要特点**

1. **动态切换**：运行时可以随时更换策略
2. **持续参与**：策略对象参与整个业务流程
3. **行为封装**：每种策略封装一种算法或行为
4. **上下文依赖**：需要上下文对象来使用策略



### **策略接口**

```java
// 出行策略接口
interface TravelStrategy {
    void travel(String destination);
}
```



### 具体出行策略

```java
class WalkStrategy implements TravelStrategy {
    @Override
    public void travel(String destination) {
        System.out.println("步行前往 " + destination + " 🚶‍♂️");
    }
}

class BikeStrategy implements TravelStrategy {
    @Override
    public void travel(String destination) {
        System.out.println("骑自行车前往 " + destination + " 🚴‍♂️");
    }
}

class CarStrategy implements TravelStrategy {
    @Override
    public void travel(String destination) {
        System.out.println("开车前往 " + destination + " 🚗");
    }
}
```



### 上下文策略接口

```java
/**
 * TravelerContext 类，表示旅行者的上下文。
 */
public class TravelerContext {

    private TravelStrategy strategy;

    public void setTravelStrategy(TravelStrategy strategy) {
        this.strategy = strategy;
    }

    public void goTo(String destination) {
        if (destination != null && !"".equals(destination)) {
            strategy.travel(destination);
            return;
        }
        throw new IllegalArgumentException("目的地不能为空");
    }
}
```



### 测试

```java
public class Main {

    public static void main(String[] args) {
        TravelerContext travelerContext = new TravelerContext();

        // 设置旅行策略为骑自行车
        travelerContext.setTravelStrategy(new BikeStrategy());
        travelerContext.goTo("公园");

        // 设置旅行策略为开车
        travelerContext.setTravelStrategy(new CarStrategy());
        travelerContext.goTo("商场");

        // 设置旅行策略为步行
        travelerContext.setTravelStrategy(new WalkStrategy());
        travelerContext.goTo("学校");
    }
}
```



### 输出

```powershell
骑自行车前往 公园 🚴‍♂️
开车前往 商场 🚗
步行前往 学校 🚶‍♂️
```

