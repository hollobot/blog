# JVM 面试题

![jvm.DBUWJQcj](./assets/jvm.DBUWJQcj.svg)

## 1. Jdk和Jre和JVM的区别

JDK、JRE 和 JVM 是 Java 生态中三个核心概念，它们层层递进，分别对应 “开发工具”“运行环境” 和 “执行引擎”，具体区别如下：

#### 1. JVM（Java Virtual Machine，Java 虚拟机）

- **定义**：是运行 Java 字节码（`.class` 文件）的虚拟计算机，是 Java 实现 “一次编写，到处运行（Write Once, Run Anywhere）” 的核心。
- **作用**：负责将字节码翻译成机器码并执行，屏蔽了底层操作系统和硬件的差异（如 Windows、Linux 上的 JVM 实现不同，但能执行相同的字节码）。
- **特点**：本身不包含任何 Java 类库，仅提供字节码执行的基础能力（如类加载、内存管理、垃圾回收等）。

#### 2. JRE（Java Runtime Environment，Java 运行时环境）

- **定义**：是运行 Java 程序的最小环境，包含 JVM 以及**运行 Java 程序必需的类库**。
- 组成
  - JVM（虚拟机，核心执行引擎）；
  - 核心类库（如 `java.lang`、`java.util` 等，位于 `rt.jar` 中）；
  - 其他支持文件（如配置文件、资源文件等）。
- **作用**：若只需运行已编译好的 Java 程序（`.class` 或 `.jar`），安装 JRE 即可，无需 JDK。

#### 3. JDK（Java Development Kit，Java 开发工具包）

- **定义**：是 Java 开发人员使用的工具包，包含 JRE 以及**开发 Java 程序所需的工具**。
- 组成
  - JRE（包含 JVM 和核心类库）；
  - 编译工具（`javac`：将 `.java` 源文件编译为 `.class` 字节码）；
  - 调试工具（`jdb`：用于调试 Java 程序）；
  - 文档工具（`javadoc`：生成 API 文档）；
  - 其他工具（如 `jar`：打包工具，`jps`：查看 Java 进程等）。
- **作用**：用于开发 Java 程序，必须安装 JDK 才能编写、编译和调试代码。

#### 三者关系总结

- **包含关系**：JDK ⊇ JRE ⊇ JVM
  - JDK = JRE + 开发工具；
  - JRE = JVM + 运行类库。
- **使用场景**：
  - 开发 Java 程序 → 需安装 JDK（因为需要 `javac` 等工具）；
  - 仅运行 Java 程序 → 安装 JRE 即可（无需开发工具）；
  - JVM 是底层执行引擎，无法单独安装，随 JRE/JDK 一起部署。

简单来说：

- JVM 是 “运行字节码的机器”；
- JRE 是 “让 Java 程序跑起来的最小环境”；
- JDK 是 “让开发者能写出 Java 程序的工具集”。



## 2. 说一下 JVM由那些部分组成，运行流程是什么？

#### 一、JVM 核心组成（3 大模块 + 2 个辅助）

1. **类加载子系统**：把 `.class` 字节码加载到 JVM，做 3 件事 —— 加载（读字节码）、链接（验证 / 准备 / 解析）、初始化（执行静态代码 / 赋值），遵循双亲委派模型。
2. **运行时数据区**：JVM 内存划分，核心是 5 块 ——
   - 线程私有：程序计数器（记指令地址）、虚拟机栈（存方法栈帧）、本地方法栈（给 native 方法用）；
   - 线程共享：堆（存对象 / 数组，GC 主要区域）、方法区（存类元数据，JDK8 后叫元空间）。
3. **执行引擎**：JVM 的 “CPU”，分解释器（逐行执行，启动快）和 JIT 编译器（把热点代码编译成机器码，执行快），搭配 GC 回收堆内存。
4. **辅助**：本地方法接口（JNI，调用 C/C++ 方法）+ 本地方法库（存 native 实现）。

#### 二、JVM 运行流程（Java 程序执行步骤）

1. 先编译：`javac`把 `.java` 转成 `.class` 字节码；
2. 类加载：类加载子系统把 `.class` 加载到方法区，完成初始化；
3. 执行：执行引擎解释 / 编译字节码，线程在私有内存里跑，对象在堆里分配；
4. 收尾：GC 回收无用对象，所有线程跑完，JVM 退出。



## 3. 说一下 JVM 运行时数据区？

JVM 运行时数据区是 Java 程序执行时内存分配和管理的核心区域，根据《Java 虚拟机规范》，分为 **线程私有** 和 **线程共享** 两大类，具体划分如下：

#### 一、线程私有区域（每个线程独立拥有，随线程生命周期创建 / 销毁）

1. **程序计数器（Program Counter Register）**
   - 作用：记录当前线程正在执行的字节码指令地址（行号），是线程切换后恢复执行的 “路标”。
   - 特点：
     - 线程私有，互不干扰。
     - 若执行的是 native 方法（非 Java 实现），计数器值为 `undefined`。
     - 唯一不会抛出 `OutOfMemoryError` 的区域。
2. **Java 虚拟机栈（Java Virtual Machine Stack）**
   - 作用：存储方法调用时的栈帧（Stack Frame），每个方法从调用到结束对应一个栈帧的入栈和出栈。
   - 栈帧包含：
     - 局部变量表（存放方法参数和局部变量，编译期确定大小）；
     - 操作数栈（临时数据运算的工作区）；
     - 动态链接（指向方法区中该方法的元数据引用）；
     - 方法返回地址（方法结束后回到调用处的指令地址）。
   - 特点：
     - 线程私有，栈深度有限制（可通过 `-Xss` 调整）。
     - 栈溢出：深度超过限制抛 `StackOverflowError`（如递归调用过深）。
     - 内存不足：动态扩展时无法申请内存抛 `OutOfMemoryError`。
3. **本地方法栈（Native Method Stack）**
   - 作用：类似虚拟机栈，但为 native 方法（如 C/C++ 实现的方法）提供内存支持。
   - 特点：
     - 线程私有，具体实现由 JVM 厂商决定（如 HotSpot 直接将其与虚拟机栈合并）。
     - 可能抛出 `StackOverflowError` 或 `OutOfMemoryError`。

#### 二、线程共享区域（所有线程共享，随 JVM 启动 / 关闭创建 / 销毁）

1. **堆（Heap）**
   - 作用：JVM 中最大的内存区域，**几乎所有对象实例和数组** 都在这里分配内存。
   - 特点：
     - 线程共享，是垃圾回收（GC）的核心区域（“GC 堆”）。
     - 内存划分：通常分为新生代（Eden 区 + 两个 Survivor 区）和老年代，不同区域采用不同 GC 算法（如新生代用复制算法，老年代用标记 - 整理算法）。
     - 内存不足：无法分配对象时抛 `OutOfMemoryError: Java heap space`。
     - 可通过 `-Xms`（初始堆大小）和 `-Xmx`（最大堆大小）调整。
2. **方法区（Method Area）**
   - 作用：存储已加载类的元数据信息，包括：类结构（类名、父类、接口）、常量池（字符串常量、符号引用等）、静态变量、方法字节码、构造函数等。
   - 特点：
     - 线程共享，逻辑上属于堆的一部分，但有独立实现。
     - JDK 8 及以后：用 **元空间（Metaspace）** 实现，元空间使用本地内存（不在 JVM 堆内存中），默认无上限（可通过 `-XX:MaxMetaspaceSize` 限制）。
     - JDK 7 及以前：用 **永久代（Permanent Generation）** 实现，属于 JVM 堆内存，易因类加载过多导致溢出。
     - 内存不足：无法加载类时抛 `OutOfMemoryError: Metaspace`（JDK8+）或 `PermGen space`（JDK7-）。

#### 总结

- **线程私有**：程序计数器、虚拟机栈、本地方法栈 → 随线程生灭，负责方法执行的上下文管理。
- **线程共享**：堆、方法区 → 全局共享，堆存对象数据，方法区存类元数据，是内存优化和 GC 的重点关注区域。



## 4. 谈谈 JVM 中的常量池？

JVM 中的常量池是存储常量信息的关键区域，主要用于存放编译期生成的各种字面量和符号引用，是类加载后进入方法区（JDK 8 后为元空间）的重要数据结构。常量池按阶段可分为 **Class 文件常量池**、**运行时常量池**，此外还有字符串常量池（特殊的运行时常量池），具体如下：

#### 1. Class 文件常量池（Class Constant Pool）

- **定义**：存在于 `.class` 字节码文件中，是编译期生成的静态数据结构，记录类中所有的常量信息。

- 内容

  - **字面量**：如字符串（`"abc"`）、基本类型常量（`123`、`true`）、声明为 `final` 的常量等。

  - 符号引用

    ：编译时无法确定实际内存地址，仅以符号形式存在的引用，包括：

    - 类和接口的全限定名（如 `java/lang/String`）；
    - 方法和字段的名称及描述符（如 `add:(II)I` 表示方法名 `add`，参数为两个 `int`，返回 `int`）。

- **作用**：为类加载后的 “解析” 阶段提供原始数据，后续会被转化为运行时常量池中的直接引用（内存地址）。

#### 2. 运行时常量池（Runtime Constant Pool）

- **定义**：Class 文件常量池被类加载器加载到 JVM 后，进入方法区（元空间）形成的内存结构，是动态的、可扩展的。
- 与 Class 文件常量池的区别
  - 前者是静态的（字节码文件中的数据），后者是动态的（加载到内存后的数据）。
  - 运行时常量池会将 Class 文件中的符号引用解析为**直接引用**（如对象的内存地址、方法的入口地址），供执行引擎直接使用。
- 特点
  - 具备动态性：不仅可以存储编译期常量，还能在运行时新增常量（如通过 `String.intern()` 方法将字符串加入常量池）。
  - 内存限制：属于方法区，若常量过多导致方法区内存不足，会抛出 `OutOfMemoryError`（如 JDK 7 前的永久代溢出，JDK 8+ 的元空间溢出）。

#### 3. 字符串常量池（String Constant Pool）

- **定义**：是运行时常量池的特殊子集，专门用于存储字符串常量，目的是**减少字符串重复创建，节省内存**（享元模式）。

- 位置变化

  - JDK 7 及以前：存在于方法区的永久代中。
  - JDK 7 及以后：迁移到**堆内存**中（因为永久代内存有限，易溢出，堆内存更灵活）。

- 核心机制

  - 字符串常量池中的字符串是唯一的，通过 `String.intern()` 方法可将字符串对象加入常量池（若不存在则创建，存在则返回常量池中的引用）。

  - 示例：

    ```java
    String s1 = "abc"; // "abc" 直接在常量池创建
    String s2 = new String("abc"); // 堆中创建对象，引用常量池的 "abc"
    String s3 = s2.intern(); // 返回常量池中的 "abc" 引用
    System.out.println(s1 == s3); // true（均指向常量池）
    ```

#### 总结

- **Class 文件常量池**：编译期静态数据，存字面量和符号引用。
- **运行时常量池**：加载到内存后的动态结构，将符号引用转为直接引用，支持运行时新增常量。
- **字符串常量池**：特殊的运行时常量池，存唯一字符串，优化内存使用。



## 5. 谈谈动态年龄判断？

动态年龄判断是 JVM 垃圾回收（尤其是新生代 GC）中用于决定对象是否晋升到老年代的一种策略，主要应用于 **SerialGC、Parallel Scavenge** 等采用分代回收的收集器中，目的是灵活处理 Survivor 区空间不足的情况，避免对象频繁在 Survivor 区之间复制。

#### 核心逻辑

在新生代中，对象通常在 Eden 区创建，经过一次 Minor GC 后，存活对象会被复制到 Survivor 区（From 区），并记录年龄（初始为 1）。之后每经历一次 Minor GC 且存活，年龄就 +1。

默认情况下，当对象年龄达到 **-XX:MaxTenuringThreshold**（默认 15，最大值 15，因年龄用 4 位二进制存储）时，会被晋升到老年代。

但 **动态年龄判断** 允许在对象年龄未达阈值时，提前晋升：

- 当 Survivor 区中 **相同年龄区间的所有对象总大小之和 ≥ Survivor 区的一半** 时，即 年龄 ≥ 该年龄的所有对象会直接晋升到老年代。

#### 举例说明

假设 Survivor 区总大小为 100MB，当前各年龄对象占用情况：

- 年龄 1：30MB
- 年龄 2：25MB
- 年龄 3：40MB

此时，年龄 3 的对象总大小（40MB）≥ 100MB 的一半（50MB？不，40 < 50，不满足）。若年龄 2 + 年龄 3 总大小为 65MB（≥50MB），则年龄 ≥2 的所有对象（25MB +40MB）会直接晋升到老年代，无需等待年龄达 15。



## 6. JVM 如何确定垃圾对象？

JVM 判断对象是否为 “垃圾”（即不再被使用的对象），核心是判断对象是否还存在**引用**。目前主流的判断算法有两种：**引用计数法**和**可达性分析算法**，其中后者是 JVM 实际采用的标准方法。

#### 1. 引用计数法（Reference Counting）

- **原理**：给每个对象添加一个 “引用计数器”，每当有一个地方引用该对象时，计数器值 +1；当引用失效时，计数器值 -1。当计数器值为 0 时，认为该对象是垃圾。
- **优点**：实现简单，判断效率高。
- 缺点
  - 无法解决**循环引用**问题（如对象 A 引用对象 B，对象 B 引用对象 A，两者计数器均为 1，但实际已无外部引用，却无法被回收）。
  - 额外的计数器维护会带来性能开销。
- **现状**：JVM 未采用这种算法（因循环引用问题无法解决），一些其他语言（如 Python）会结合其他机制使用。

#### 2. 可达性分析算法（Reachability Analysis）

这是 JVM 普遍采用的垃圾判断算法，核心是通过 “引用链追踪” 判断对象是否可达。

- **原理**：
  - 以一系列称为 **“GC Roots”** 的对象为起点，向下搜索所有可达的对象（即能通过引用链从 GC Roots 直接或间接访问到的对象）。
  - 最终**未被搜索到的对象**（即与 GC Roots 无任何引用链连接），被判定为垃圾，可被回收。
- **GC Roots 的常见类型**（必须是**确定存活的对象**）：
  1. 虚拟机栈（栈帧中的局部变量表）中引用的对象（如方法参数、局部变量）。
  2. 方法区中类静态属性引用的对象（如 `static` 变量引用的对象）。
  3. 方法区中常量引用的对象（如字符串常量池中的引用）。
  4. 本地方法栈中 JNI（Native 方法）引用的对象。
  5. 活跃线程（如正在运行的线程对象）。
- **示例**：若一个对象既不在虚拟机栈的局部变量中，也不被静态变量或常量引用，且没有任何活跃线程持有它的引用，则通过可达性分析会被判定为不可达，成为垃圾。

#### 3. 补充：引用的类型（影响垃圾判断）

JDK 1.2 后，Java 对 “引用” 进行了扩充，分为 4 种类型，不同类型的引用会影响对象被回收的时机：

- **强引用**（默认）：如 `Object obj = new Object()`，只要强引用存在，对象就不会被回收（即使 OOM 也不回收）。
- **软引用**（`SoftReference`）：内存不足时才会被回收，适合缓存场景。
- **弱引用**（`WeakReference`）：只要发生 GC，就会被回收，适合临时关联的对象。
- **虚引用**（`PhantomReference`）：无法通过引用获取对象，仅用于跟踪对象被回收的时机（必须配合引用队列使用）。

可达性分析中，只有**强引用**会使对象被判定为 “可达”；其他类型的引用不会阻止对象被回收（仅影响回收时机）。

#### 总结

JVM 主要通过**可达性分析算法**判断垃圾对象：以 GC Roots 为起点，不可达的对象被标记为垃圾。这种方法解决了循环引用问题，是现代 JVM（如 HotSpot）的标准实现。而引用类型的划分，让开发者可以更灵活地控制对象的生命周期。



## 7. 强引用、软引用、弱引用、虚引用是什么，有什么区别？

强引用、软引用、弱引用、虚引用是 Java 中不同强度的引用类型，核心区别在于**引用与对象的绑定力度**，以及**对象被垃圾回收（GC）的时机**，它们共同决定了对象的生命周期灵活性。

#### 1. 强引用（Strong Reference）

- **定义**：Java 默认的引用类型，是最常见的引用方式（如 `Object obj = new Object()`），代表对象与引用之间的 “强绑定”。

- **GC 行为**：只要强引用存在，即使 JVM 内存不足（OOM 边缘），也**绝对不会回收**被引用的对象。

- **使用场景**：日常开发中最普遍的对象引用，如普通变量、集合元素等（需要确保对象在使用期间不被回收）。

- 示例

  ```java
  Object strongRef = new Object(); // 强引用
  strongRef = null; // 断开强引用，对象才可能被 GC 回收
  ```

#### 2. 软引用（Soft Reference）

- **定义**：通过 `java.lang.ref.SoftReference` 类实现，引用强度弱于强引用，是 “内存敏感型” 引用。

- GC 行为

  - 内存充足时，对象不会被回收；
  - 内存不足（即将发生 OOM）时，GC 会**主动回收**所有被软引用关联的对象。

- **使用场景**：适合作为**缓存**（如图片缓存、数据缓存），既利用缓存提升效率，又避免内存溢出。

- 示例

  ```java
  Object obj = new Object();
  SoftReference<Object> softRef = new SoftReference<>(obj); // 软引用
  obj = null; // 断开强引用，对象仅被软引用关联
  // 内存不足时，softRef 关联的对象会被 GC 回收
  ```

#### 3. 弱引用（Weak Reference）

- **定义**：通过 `java.lang.ref.WeakReference` 类实现，引用强度弱于软引用，是 “临时关联型” 引用。

- **GC 行为**：**只要发生 GC（无论内存是否充足）**，被弱引用关联的对象都会被回收，回收时机比软引用更早。

- **使用场景**：适合存储 “临时有用，但不影响核心逻辑” 的对象，如 `ThreadLocal` 内部的 Entry（避免内存泄漏）、临时数据关联等。

- 示例

  ```java
  Object obj = new Object();
  WeakReference<Object> weakRef = new WeakReference<>(obj); // 弱引用
  obj = null; // 断开强引用
  System.gc(); // 执行 GC 后，weakRef 关联的对象会被回收
  ```

#### 4. 虚引用（Phantom Reference）

- **定义**：通过 `java.lang.ref.PhantomReference` 类实现，是**最弱的引用**，几乎等同于 “没有引用”。

- GC 行为

  - 无法通过虚引用获取对象（`get()` 方法永远返回 `null`）；
  - 只要对象被虚引用关联，**发生 GC 时就会被回收**，且回收后会将虚引用加入绑定的 “引用队列”（`ReferenceQueue`），用于跟踪对象的回收时机。

- **使用场景**：仅用于**监听对象的回收事件**（如释放对象关联的底层资源，避免直接使用 `finalize()` 方法的不确定性）。

- 示例

  ```java
  Object obj = new Object();
  ReferenceQueue<Object> queue = new ReferenceQueue<>();
  PhantomReference<Object> phantomRef = new PhantomReference<>(obj, queue); // 虚引用
  obj = null;
  System.gc();
  // 回收后，phantomRef 会被加入 queue，可通过 queue.poll() 检测
  ```

#### 四种引用的核心区别对比

| 引用类型 | 引用强度 | GC 回收时机                | 能否通过引用获取对象      | 典型使用场景           |
| -------- | -------- | -------------------------- | ------------------------- | ---------------------- |
| 强引用   | 最强     | 仅当强引用断开时才可能回收 | 能（直接访问）            | 普通对象引用、业务数据 |
| 软引用   | 较弱     | 内存不足时回收             | 能（`get()` 方法）        | 缓存（图片、数据）     |
| 弱引用   | 更弱     | 只要发生 GC 就回收         | 能（`get()` 方法）        | 临时数据、避免内存泄漏 |
| 虚引用   | 最弱     | 发生 GC 就回收             | 不能（`get()` 恒为 null） | 监听对象回收事件       |

#### 总结

四种引用的强度从强到弱依次为：**强引用 > 软引用 > 弱引用 > 虚引用**。

- 强引用保证对象 “存活”，是业务逻辑的基础；
- 软 / 弱引用平衡 “缓存效率” 与 “内存安全”；
- 虚引用仅用于 “回收监听”，几乎不直接操作对象。合理使用不同引用类型，可优化内存占用，避免内存泄漏（如ThreadLocal用弱引用、缓存用软引用）。