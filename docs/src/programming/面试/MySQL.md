# MySQL常见面试题总结



## 1. 事务的四大特性？

**事务特性ACID**：**原子性**（`Atomicity`）、**一致性**（`Consistency`）、**隔离性**（`Isolation`）、**持久性**（`Durability`）。

- **原子性：**是指事务包含的所有操作要么全部成功，要么全部失败回滚。
- **一致性：**是指一个事务执行之前和执行之后都必须处于一致性状态。比如a与b账户共有1000块，两人之间转账之后无论成功还是失败，它们的账户总和还是1000。
- **隔离性：**。跟隔离级别相关，如`read committed`，一个事务只能读到已经提交的修改。
- **持久性：**是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。



##  2. 事务隔离级别有哪些？

先了解下几个概念：脏读、不可重复读、幻读。

- **脏读**是指在一个事务处理过程里读取了另一个未提交的事务中的数据。
- **不可重复读**是指在对于数据库中的某行记录，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，另一个事务修改了数据并提交了。
- **幻读**是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录。对幻读的正确理解是一个事务内的读取操作的结论不能支撑之后业务的执行。假设事务要新增一条记录，主键为id，在新增之前执行了select，没有发现id为xxx的记录，但插入时出现主键冲突，这就属于幻读，读取不到记录却发现主键冲突是因为记录实际上已经被其他的事务插入了，但当前事务不可见。

**不可重复读和脏读的区别：**脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。

事务隔离就是为了解决上面提到的脏读、不可重复读、幻读这几个问题。

MySQL数据库为我们提供的四种隔离级别：

- **Serializable** (串行化)：通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。
- **Repeatable read** (可重复读)：MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，解决了不可重复读的问题。（整个事务期间只使用第一次创建的Read View 保证同一事务内多次读取同一数据结果一致 通过固定的一致性视图实现可重复读）
- **Read committed** (读已提交)：一个事务只能看见已经提交事务所做的改变。可避免脏读的发生。
- **Read uncommitted** (读未提交)：所有事务都可以看到其他未提交事务的执行结果。



## 3. 编码和字符集的关系

我们平时可以在编辑器上输入各种中文英文字母，但这些都是给人读的，不是给计算机读的，其实计算机真正保存和传输数据都是以**二进制**0101的格式进行的。

那么就需要有一个规则，把中文和英文字母转化为二进制。其中d对应十六进制下的64，它可以转换为01二进制的格式。于是字母和数字就这样一一对应起来了，这就是**ASCII编码**格式。

它用**一个字节**，也就是`8位`来标识字符，基础符号有128个，扩展符号也是128个。也就只能表示下**英文字母和数字**。

这明显不够用。于是，为了标识**中文**，出现了**GB2312**的编码格式。为了标识**希腊语**，出现了**greek**编码格式，为了标识**俄语**，整了**cp866**编码格式。

为了统一它们，于是出现了**Unicode编码格式**，它用了2~4个字节来表示字符，这样理论上所有符号都能被收录进去，并且它还完全兼容ASCII的编码，也就是说，同样是字母d，在ASCII用64表示，在Unicode里还是用64来表示。

但**不同的地方是ASCII编码用1个字节来表示，而Unicode用则两个字节来表示。**

同样都是字母d，unicode比ascii多使用了一个字节，如下：

```mysql
D   ASCII:           01100100
D Unicode:  00000000 01100100
```

可以看到，上面的unicode编码，前面的都是0，其实用不上，但还占了个字节，有点浪费。如果我们能做到该隐藏时隐藏，这样就能省下不少空间，按这个思路，就是就有了**UTF-8编码**。

总结一下，按照一定规则把符号和二进制码对应起来，这就是**编码**。而把n多这种已经编码的字符聚在一起，就是我们常说的**字符集**。

比如utf-8字符集就是所有utf-8编码格式的字符的合集。

想看下mysql支持哪些字符集。可以执行 `show charset`;



## 4. utf8和utf8mb4的区别

UTF-8 和 UTF8mb4 都是 Unicode 字符集的编码方式，主要区别在于对 ** supplementary characters（增补字符）** 的支持能力，以及由此带来的存储范围差异。以下是具体区别：

#### 1. **编码范围不同**

- **UTF-8**：是最常见的 UTF-8 编码实现，支持 **Unicode 基本多文种平面（BMP）** 中的字符，即 U+0000 到 U+FFFF 范围内的字符（包括绝大多数常用字符，如中文、英文、日文等）。每个字符的编码长度为 1~3 字节。
- **UTF8mb4**：是 “UTF-8 most bytes 4” 的缩写，支持 **全部 Unicode 字符**，包括基本多文种平面（U+0000~U+FFFF）和 **增补平面（U+10000~U+10FFFF）** 中的字符（如 emoji 表情、某些罕见语言字符、特殊符号等）。每个字符的编码长度为 1~4 字节。

#### 2. **核心差异：是否支持 4 字节字符**

- **UTF-8** 最多支持 3 字节编码，无法表示 Unicode 中编码值超过 U+FFFF 的字符（即 4 字节字符）。例如：
  - Emoji 表情（如 😊 U+1F60A、👍 U+1F44D）；
  - 某些罕见语言文字（如古埃及象形文字、数学符号等）；
  - 部分特殊符号（如 😂、🤣 等）。若强行存储这些字符，UTF-8 会出现编码错误或截断。
- **UTF8mb4** 支持 4 字节编码，可完整存储上述所有 Unicode 字符，包括 emoji 等增补字符。

#### 3. **应用场景（以 MySQL 为例）**

在数据库（如 MySQL）中，UTF-8 和 UTF8mb4 是常见的字符集设置，区别直接影响存储能力：

- 早期 MySQL 中的 `utf8` 实际上是 **UTF-8 的子集**（仅支持 3 字节），并非完整的 UTF-8 标准；
- `utf8mb4` 才是 MySQL 对完整 UTF-8 标准的实现（支持 4 字节）。

若数据库字段设置为 `utf8`，存储 emoji 等 4 字节字符时会报错（如 `Incorrect string value`），必须使用 `utf8mb4` 才能正常存储。

#### 4. **存储与性能影响**

- **存储空间**：UTF8mb4 由于支持 4 字节字符，在存储这类字符时会比 UTF-8 多占用 1 字节；但对于普通 1~3 字节字符（如中文、英文），两者存储长度相同，无额外开销。
- **性能**：两者在编码 / 解码效率上差异极小，实际使用中几乎无感知。但需注意：若数据库索引字段使用 UTF8mb4，且字符长度较长，可能会略微增加索引存储开销（需结合实际业务评估）。

#### 总结

| 特性                | UTF-8（狭义，如 MySQL 的 utf8） | UTF8mb4                     |
| ------------------- | ------------------------------- | --------------------------- |
| 支持的 Unicode 范围 | U+0000 ~ U+FFFF（3 字节内）     | U+0000 ~ U+10FFFF（全范围） |
| 4 字节字符支持      | ❌ 不支持（如 emoji）            | ✅ 支持                      |
| 存储长度            | 1~3 字节                        | 1~4 字节                    |
| 适用场景            | 仅需存储常见字符（无 emoji 等） | 需要存储 emoji、罕见字符等  |

**建议**：新系统开发中，若可能涉及 emoji、特殊符号或国际化罕见字符，优先使用 **UTF8mb4**，避免编码兼容性问题；若确认仅需处理基本字符，UTF-8 也可满足需求，但灵活性较低。



### 5. 什么是索引？

- 索引是存储引擎用于提高数据库表的访问速度的一种**数据结构**。它可以比作一本字典的目录，可以帮你快速找到对应的记录。
- 索引一般存储在磁盘的文件中，它是占用物理空间的。



## 6. 索引的优缺点？

- **优点**：
  - 大幅减少查询的磁盘 IO 次数，提升查询速度；
  - 优化排序、分组操作，降低 CPU 开销。
- **缺点**：
  - 占用额外磁盘空间（索引本身是独立的数据结构，需存储）；
  - 降低写操作效率（新增 / 修改 / 删除数据时，需同步更新对应的索引，避免索引与数据不一致）。



## 7. 什么情况下需要建索引？

1. 经常用于查询的字段
2. 经常用于`连接` (join) 的字段建立索引，可以加快连接的速度
3. 经常需要`排序`、`分组`的字段建立索引，因为索引已经排好序



## 8. 什么情况下不建索引？

1. 更新频繁的字段（索引会拉低写的效率）
2. 区分度很低的字段（唯一性差）如性别，只有男/女/未知三个值。加了索引，查询效率也不会提高。
3. 表数据量很少的情况。比如只有几百条数据，没必要加索引。
4. `where ` 条件中用不到的字段不适合建立索引