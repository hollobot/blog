# Redis 面试题



## 1. Redis是什么？

Redis（`Remote Dictionary Server`）是一个使用 C 语言编写的，高性能非关系型的键值对数据库。与传统数据库不同的是，Redis 的数据是存在内存中的，所以读写速度非常快，被广泛应用于缓存方向。Redis可以将数据写入磁盘中，保证了数据的安全不丢失，而且Redis的操作是原子性的



## 2. Redis优缺点？

Redis 的核心优势在于**极致性能**和**灵活的数据结构**，但同时受限于内存成本和数据一致性设计，存在明显使用边界。

#### Redis 的核心优势（优点）

1. **超高性能**：数据存储在内存中，读写速度极快，单机 QPS (每秒请求次数) 可轻松达到 10 万级别，响应延迟通常在微秒级。
2. **丰富数据结构**：原生支持字符串、哈希、列表、集合、有序集合等，无需额外封装就能满足复杂业务需求（如排行榜、计数器）。
3. **高可用与可扩展**：支持主从复制、哨兵模式和集群部署，能实现故障自动切换和水平扩容，保障服务稳定性。
4. **功能全面**：自带持久化（RDB/AOF）、过期淘汰、发布订阅、事务等功能，可覆盖缓存、消息队列、会话存储等多场景。

#### Redis 的主要局限（缺点）

1. **内存成本高**：数据依赖内存存储，大规模数据场景下硬件成本远高于磁盘数据库（如 MySQL）。
2. **数据容量受限**：单实例数据量受物理内存大小限制，即使集群部署，也需合理规划分片以控制单节点内存占用。
3. **强一致性支持弱**：默认采用异步复制，主从节点间可能存在数据延迟，无法完全满足金融级等强一致性要求的场景。
4. **持久化有代价**：RDB 可能丢失短时间数据，AOF 日志文件会随时间增大，需定期重写，过程中会占用额外资源。



## 3. Redis为什么这么快？

Redis 之所以性能极高（单机 QPS 可达 10 万 +，响应延迟微秒级），核心源于其**底层设计对 “高性能” 的极致优化**，具体可从以下几个层面拆解：

#### 1. **基于内存存储，避开磁盘 I/O 瓶颈**

Redis 的数据**主要存储在内存中**，而内存的读写速度（微秒级）远高于磁盘（毫秒级，差距约 10 万倍）。传统数据库（如 MySQL）需频繁读写磁盘，而 Redis 几乎所有操作都在内存中完成，天然规避了磁盘 I/O 这个性能瓶颈。

#### 2. **单线程模型，避免多线程切换开销**

Redis 采用**单线程处理核心请求**（网络 I/O 和数据操作由一个主线程完成），这看似 “反常识”，却带来两大优势：

- **无线程切换成本**：多线程需频繁进行 CPU 上下文切换（保存 / 恢复线程状态），而单线程无需处理这些开销，减少了性能损耗。
- **无锁竞争**：单线程操作共享数据时，无需加锁（如互斥锁），避免了锁竞争带来的阻塞和性能波动。

*注：Redis 并非完全单线程，后台持久化（RDB/AOF）、集群同步等操作由额外线程处理，不影响主线程的请求处理。*

#### 3. **高效的数据结构设计**

Redis 针对每种数据结构（字符串、哈希、列表、集合等）都做了**极致优化**，底层实现并非简单的数组或链表，而是结合场景选择最高效的结构：

- **字符串（String）**：基于动态字符串（SDS）实现，预分配空间减少内存重分配次数，支持直接修改部分内容（无需整体复制）。
- **哈希（Hash）**：小规模数据用压缩列表（ziplist）存储（节省内存，连续内存访问更快），数据量大时自动转为哈希表，兼顾读写效率。
- **列表（List）**：底层是 “双向链表 + 压缩列表”，插入 / 删除首尾元素复杂度为 O (1)，且压缩列表适合存储短数据，减少内存碎片。
- **有序集合（Sorted Set）**：基于跳表（skiplist）实现，支持 O (logN) 的插入、查询和排序，比平衡树实现更简单，性能更稳定。

#### 4. **I/O 多路复用技术，高效处理并发连接**

Redis 采用 **I/O 多路复用模型**（如 Linux 的 `epoll`、Windows 的 `IOCP`），通过一个线程同时监听多个网络连接，批量处理 I/O 事件：

- 传统阻塞 I/O 需为每个连接创建线程，线程数过多会导致资源耗尽；而多路复用可在单线程内高效处理数万甚至数十万连接，大幅降低资源消耗。
- `epoll` 等机制采用 “事件驱动” 模式，仅当连接有数据可读 / 可写时才触发处理，避免无效的轮询开销。

#### 总结

Redis 的高性能是**内存存储 + 单线程模型 + 高效数据结构 + I/O 多路复用**四大核心因素共同作用的结果，每一层设计都围绕 “减少开销、提升效率” 展开，最终实现了远超传统数据库的响应速度。



## 4. 既然Redis那么快，为什么不用它做主数据库，只用它做缓存？

Redis 不做主数据库，核心是它的优势（快）恰好对应了主数据库的核心需求（可靠存海量数据、支持复杂操作）的短板，具体可简化为三点：

1. **存海量数据成本太高**：Redis 靠内存存数据，成本远高于磁盘数据库，存全量业务数据不划算。
2. **数据可靠性不足**：持久化机制（RDB/AOF）可能丢数据，核心业务（如订单、交易）无法接受。
3. **不支持复杂需求**：没有 SQL 那样的复杂查询能力，事务功能也弱，满足不了主数据库的业务场景。

所以它更适合做缓存，专门加速高频访问的热点数据，而非替代主数据库存全量核心数据。



## 5. 讲讲Redis的线程模型？

Redis 的线程模型可以概括为 **“单线程处理核心请求 + 多线程处理辅助任务”**，这种设计既保证了核心操作的高效性，又避免了单线程在辅助任务上的性能瓶颈。

#### 1. **核心：单线程处理网络 I/O 和数据操作**

Redis 的**主线程是单线程**，负责处理所有客户端的网络请求（连接建立、数据读写）和核心数据操作（如 `set`、`get`、哈希 / 列表操作等）。

- **为什么用单线程？**

  因为 Redis 的数据都在内存中，操作速度极快（微秒级），而多线程的上下文切换、锁竞争等开销反而会降低效率。单线程无需处理这些问题，能最大化利用 CPU 资源。

- **如何处理并发连接？**

  依赖I/O 多路复用技术（如 Linux 的 epoll）：主线程通过一个 “事件循环” 监听多个客户端连接，批量处理就绪的 I/O 事件（如 “客户端发送数据”“连接断开”），无需为每个连接创建线程，高效支撑数万并发连接。

#### 2. **辅助：多线程处理非核心任务**

Redis 并非完全单线程，从 4.0 版本开始引入多线程处理**非核心任务**，避免阻塞主线程：

- **后台持久化**：RDB 快照生成、AOF 日志重写由专门的后台线程执行，不影响主线程处理请求。
- **异步删除**：删除大键（如包含百万元素的集合）时，用 `UNLINK` 命令触发异步删除，由后台线程逐步清理，避免主线程长时间阻塞。
- **集群同步**：主从节点间的数据同步、集群槽位迁移等操作，由独立线程处理。

#### 总结

Redis 线程模型的核心是：**用单线程高效处理核心的网络 I/O 和数据操作（避免多线程开销），用多线程处理耗时的辅助任务（避免阻塞主线程）**。这种设计既发挥了单线程的高效性，又通过多线程弥补了其在复杂任务上的短板，最终实现了超高的性能。



## 6. Redis应用场景有哪些？

Redis 凭借高性能、多数据结构和灵活特性，适合以下核心应用场景：

1. **缓存**
   - 存储高频访问数据（如商品详情、用户信息），减少数据库压力，提升响应速度。
   - 例：电商商品页缓存，用户登录后基本信息缓存。
2. **会话存储**
   - 分布式系统中存储用户登录会话（如 Session），实现多服务器间会话共享。
   - 例：用户登录状态在多台应用服务器间同步。
3. **计数器与限流**
   - 用 `INCR` 实现实时计数器（如文章阅读量、接口调用次数）。
   - 结合过期时间实现限流（如限制单 IP 每秒请求次数）。
4. **排行榜与实时排序**
   - 用有序集合（Sorted Set）实现按分数排序的排行榜（如游戏积分、商品销量排行），支持动态更新和范围查询。
5. **消息队列**
   - 用列表（List）的 `LPUSH`/`RPOP` 实现简单消息队列，解耦系统模块（如订单创建后通知库存系统）。
6. **分布式锁**
   - 基于 `SET NX` 命令实现分布式环境下的互斥锁，保证临界资源的原子操作（如秒杀库存扣减）。
7. **地理位置服务**
   - 用 GEO 类型存储经纬度，实现附近的人、商家定位等功能（如外卖平台显示周边店铺）。
8. **热点数据临时存储**
   - 存储临时高频数据（如秒杀活动库存、限时优惠券），利用过期时间自动清理。
9. **社交网络**
   - 点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。

这些场景的核心是利用 Redis 的**高速读写、多结构支持、过期机制**，解决传统数据库在性能或功能上的短板。



## 7. Memcached和Redis的区别？

#### Memcached 与 Redis 核心区别对照表

| 对比维度     | Memcached                              | Redis                                        |
| ------------ | -------------------------------------- | -------------------------------------------- |
| 核心定位     | 轻量级分布式内存缓存工具               | 多功能内存数据库（兼具缓存能力）             |
| 支持数据结构 | 仅支持 Key-Value（Value 为字符串）     | 字符串、哈希、列表、集合、有序集合、GEO 等   |
| 数据持久化   | 不支持（重启后数据全丢失）             | 支持 RDB 快照、AOF 日志（可选持久化）        |
| 分布式能力   | 依赖客户端哈希分片                     | 自带集群（Cluster）功能，支持自动分片        |
| 高级功能     | 无（仅基础缓存）                       | 支持分布式锁、计数器、排行榜、发布订阅、事务 |
| 内存管理     | 采用 Slab Allocation（易有内存碎片）   | 支持多种内存淘汰策略，可自定义内存分配器     |
| 并发性能     | 多线程模型（适合多核，但有锁开销）     | 单线程核心模型（避免锁开销，高并发更优）     |
| 适用场景     | 简单纯缓存需求（如数据库查询结果缓存） | 复杂业务场景（需多结构、持久化、高级功能）   |



## 8. 为什么要用 Redis 而不用 map/guava 做缓存?

Guava 是 Google 开源的 **Java 工具类库**，里面包含了很多实用工具，其中 `Guava Cache` 是它提供的**单机内存缓存组件**。它能解决普通 Map 做缓存的痛点（如自动过期、容量限制、缓存淘汰），但本质还是 “运行在单个 JVM 进程内的缓存”，无法跨服务器共享。

总结核心：Map、Guava Cache、Redis 的本质和适用场景完全不同，选择的关键是 “是否分布式”“是否需缓存管理能力”：

1. **普通 Map**：只是基础内存数据结构，无缓存管理（过期、淘汰），仅适合单线程、临时存少量数据（如方法内临时数据）。
2. **Guava Cache**：是单机内存缓存组件，支持自动过期、LRU 淘汰，适合**单机应用**（无需跨服务共享）的本地缓存（如单服务配置缓存）。
3. **Redis**：是分布式内存缓存系统，支持跨服务共享、持久化、集群扩容，适合**分布式系统**（多服务共享数据、需高可用 / 大容量）的场景（如共享会话、秒杀库存）。

简单说：单机小场景用 Guava，分布式大场景用 Redis，Map 仅能做临时存储，不能算 “正经缓存工具”。



## 9. Redis 数据类型有哪些？

Redis 核心支持 8 种数据类型，可按 “基础常用” 和 “特殊场景” 分类，每种类型对应特定业务需求，核心总结如下：

#### 1. 基础常用类型（5 种）

- **字符串（String）**：最基础类型，值可存字符串、数字或二进制数据（如图片 base64），支持 `SET`/`GET`/`INCR`（自增）等操作，适合存单个值（如用户昵称、商品库存）。
- **哈希（Hash）**：键值对的集合（类似 Java 的 HashMap），键和值都是字符串，支持单独操作某个字段（如 `HSET user:1 name "张三"`），适合存结构化数据（如用户信息、商品详情）。
- **列表（List）**：有序的字符串集合（底层是双向链表），支持从首尾增删元素（`LPUSH`/`RPOP`），适合做消息队列、最新消息列表（如朋友圈动态）。
- **集合（Set）**：无序的字符串集合，自动去重，支持交集、并集、差集（如 `SINTER` 求共同好友），适合存不重复数据（如用户标签、抽奖中奖名单）。
- **有序集合（Sorted Set）**：带分数（score）的 Set，按分数自动排序，支持按分数范围查询（如 `ZRANGEBYSCORE`），适合做排行榜（如游戏积分、商品销量排行）。

#### 2. 特殊场景类型（3 种）

- **地理位置（GEO）**：存储经纬度数据，支持计算两点距离、查询附近的点（如 `GEORADIUS` 查周边商家），适合 LBS 服务（如外卖、打车定位）。
- **位图（Bitmap）**：用二进制位存储数据（1 个键对应多个二进制位），支持位运算（如 `BITCOUNT` 统计活跃天数），适合存海量布尔值（如用户签到、是否在线）。
- **基数统计（HyperLogLog）**：用极小内存统计集合的不重复元素个数（误差约 0.81%），适合海量数据去重计数（如统计网站独立访客 UV）。

简单说：基础类型覆盖多数常规场景，特殊类型针对定位、海量统计等细分需求，选择时需结合 “数据结构” 和 “业务操作” 匹配。



## 10. SortedSet和List异同点？

Redis 的 SortedSet（有序集合）和 List（列表）都是 “有序的元素集合”，但核心差异在于**排序机制、去重能力和适用场景**，具体异同点总结如下：

#### 一、相同点

1. **元素有序性**：两者存储的元素都有顺序，支持按顺序获取元素（如获取前 N 个、后 N 个）。
2. **元素类型**：元素均为字符串类型，且都支持动态增删元素。
3. **支持范围操作**：都能按 “位置范围” 获取元素（如 List 的 `LRANGE`、SortedSet 的 `ZRANGE`）。

#### 二、核心差异（关键区别）

| 对比维度     | List（列表）                                   | SortedSet（有序集合）                                        |
| ------------ | ---------------------------------------------- | ------------------------------------------------------------ |
| **排序机制** | 按 “插入顺序” 排序（插入时的先后决定位置）     | 按 “用户指定的 score（分数）” 排序，自动维护有序性           |
| **去重能力** | 允许重复元素（同一值可多次插入，位置不同）     | 自动去重（元素值唯一，重复插入会更新 score）                 |
| **核心操作** | 支持首尾快速增删（`LPUSH`/`RPOP`）、按索引操作 | 支持按 score 排序 / 查询（`ZRANGEBYSCORE`）、修改 score（`ZINCRBY`） |
| **适用场景** | 需按插入顺序存储的场景（如消息队列、最新动态） | 需按自定义规则排序的场景（如排行榜、带权重的任务调度）       |

#### 三、总结

- **用 List**：当你需要 “按插入顺序保存元素，允许重复，且需快速操作首尾” 时（如消息队列按发送顺序消费、存储用户最新浏览记录）。
- **用 SortedSet**：当你需要 “按自定义分数排序，自动去重，且需按分数筛选” 时（如游戏积分排行榜按分数降序、按用户等级排序展示）。

简单说：List 是 “插入有序”，SortedSet 是 “score 有序”，去重和排序逻辑的不同决定了它们的适用场景完全不同。



## 11. Redis的内存用完了会怎样？

Redis 内存用完后的行为，核心由 **是否配置 maxmemory** 和 **内存淘汰策略** 决定，总结为两点：

1. **未配置 maxmemory（默认）**：Redis 会持续占满服务器内存，最终可能被操作系统的 OOM killer 杀死，导致数据丢失，风险高。

2. 配置了 maxmemory

   ：内存达上限时触发预设策略，分两类：

   - 拒绝写入（默认 `noeviction`）：新写请求报错，读请求正常，适合不允许丢数据的场景；
   - 主动淘汰（如 `allkeys-lru`、`volatile-lru`）：按规则淘汰旧数据（如最近最少用、过期时间最短）释放空间，适合缓存场景，需按业务选策略。

实际用的时候，推荐配置 `maxmemory` 并搭配 LRU 类策略（如 `allkeys-lru`），同时监控内存避免频繁淘汰。



## 12. Redis如何做内存优化？

Redis 内存优化核心是 “减少占用、提升效率”，关键策略总结为：

1. **选对数据结构**：
   - 用紧凑编码（如 ziplist 哈希、整数编码字符串），避免拆分数据（一个 Hash 存多字段比多 String 省空间）；
   - 海量布尔值用 Bitmap，替代 Set/String。
2. **优化存储格式**：
   - 缩短键名 / 字段名（如 `u:1:n` 代替 `user:1:name`）；
   - 大值数据（如 JSON）压缩后存储。
3. **合理配置策略**：
   - 设 `maxmemory` 及淘汰策略（如 `allkeys-lru` 淘汰冷数据）；
   - 临时数据加过期时间，避免集中过期（加随机值分散）。
4. **利用内置特性**：
   - 开启自动内存碎片整理；
   - 用高效的内存分配器（jemalloc）。
5. **分布式分片**：集群 / 分片分散数据，避免单节点内存过载。

核心逻辑：针对性减少冗余存储，结合配置和特性控制内存增长，平衡空间与性能。



## 13. Redis存在线程安全问题吗？

Redis 的线程安全问题需分 **服务端** 和 **客户端** 两层看，核心结论是 “服务端天然安全，客户端需额外保障”，具体总结如下：

1. **服务端层面：无线程安全问题**

   - Redis 本质是线程安全的 K-V 数据库，即使 6.0+ 引入多线程，也仅用于处理网络 IO 事件（如接收请求、返回结果）。
   - 所有指令的执行仍由 **主线程串行处理**（一个接一个，无并发执行），指令本身是原子操作，无需额外同步机制，不会出现数据不一致。

2. **客户端层面：存在线程安全风险**

   - 虽服务端单条指令原子，但多个客户端（或同一客户端多线程）并发执行 “多指令组合操作” 时，原子性无法保障。

   - 例：两个客户端同时读取 k = 10 的值、在执行扣减操作 `set k 9` 导致最终数据还是9，导致业务逻辑错误，少扣减库存。

   - 解决方案：用 Redis 原子指令（如 `INCR` 自增原子指令）、加分布式锁、或通过 Lua 脚本将多指令打包成原子操作。

     ```sh
     # 初始：key不存在时，默认从0开始自增
     127.0.0.1:6379> INCR visit_count  # 对"访问量计数器"自增1
     (integer) 1  # 结果：1（初始化为0，+1后为1）
     
     # 对"商品库存"每次增加10件
     127.0.0.1:6379> INCRBY goods_stock 10
     (integer) 10  # 初始库存10
     ```

简言之，Redis 服务端靠 “主线程串行执行指令” 保证安全，客户端需通过合理设计规避多端并发带来的风险。